from z3 import *
s = SolverFor("QF_LIA")
# (set-logic QF_LIA)
s.set("model.completion", True)
# (set-option :produce-models true)
# s = Solver()

A, B, C, D, E, F, At, Bt, Ct, Dt, Et, Ft, End = Ints('A B C D E F At Bt Ct Dt Et Ft End')

# A = Function('A', (), IntSort())
s.add(A >= 0)
# (declare-fun A () Int)
# (assert (>= A 0))
# At = Function('At', None, IntSort())
s.add(At == 2)
# (declare-fun At () Int)
# (assert (= At 2))
# B = Function('B', None, IntSort())
s.add(B >= 0)
# (declare-fun B () Int)
# (assert (>= B 0))
# Bt = Function('Bt', None, IntSort())
s.add(Bt == 1)
# (declare-fun Bt () Int)
# (assert (= Bt 1))
# C = Function('C', None, IntSort())
s.add(C >= 0)
# (declare-fun C () Int)
# (assert (>= C 0))
# Ct = Function('Ct', None, IntSort())
s.add(Ct == 2)
# (declare-fun Ct () Int)
# (assert (= Ct 2))
# D = Function('D', None, IntSort())
s.add(D >= 0)
# (declare-fun D () Int)
# (assert (>= D 0))
# Dt = Function('Dt', None, IntSort())
s.add(Dt == 2)
# (declare-fun Dt () Int)
# (assert (= Dt 2))
# E = Function('E', None, IntSort())
s.add(E >= 0)
# (declare-fun E () Int)
# (assert (>= E 0))
# Et = Function('Et', None, IntSort())
s.add(Et == 7)
# (declare-fun Et () Int)
# (assert (= Et 7))
# F = Function('F', None, IntSort())
s.add(F >= 0)
# (declare-fun F () Int)
# (assert (>= F 0))
# Ft = Function('Ft', None, IntSort())
s.add(Ft == 5)
# (declare-fun Ft () Int)
# (assert (= Ft 5))

s.add(Or((A+At)<=C, (C+Ct)<=A))
# (assert (or (<= (+ A At) C) (<= (+ C Ct) A)))
s.add(Or((B+Bt)<=D, (D+Dt)<=B))
# (assert (or (<= (+ B Bt) D) (<= (+ D Dt) B)))
s.add(Or((B+Bt)<=E, (E+Et)<=B))
# (assert (or (<= (+ B Bt) E) (<= (+ E Et) B)))
s.add(Or((D+Dt)<=E, (E+Et)<=D))
# (assert (or (<= (+ D Dt) E) (<= (+ E Et) D)))
s.add(And((D+Dt)<=F, (E+Et)<=F))
# (assert (and (<= (+ D Dt) F) (<= (+ E Et) F)))
s.add((A+At)<=B)
# (assert (<= (+ A At) B))

# End = Function('End', None, IntSort())
# (declare-fun End () Int)
s.add(End == 14)
# (assert (= End 14))
s.add((A+At) <= End)
# (assert (<= (+ A At) End))
s.add((B+Bt) <= End)
# (assert (<= (+ B Bt) End))
s.add((C+Ct) <= End)
# (assert (<= (+ C Ct) End))
s.add((D+Dt) <= End)
# (assert (<= (+ D Dt) End))
s.add((E+Et) <= End)
# (assert (<= (+ E Et) End))
s.add((F+Ft) <= End)
# # (assert (<= (+ F Ft) End))


# one solution
# print("A", s.model()[A])
# print("B", s.model()[B])
# print("C", s.model()[C])
# print("D", s.model()[D])
# print("E", s.model()[E])
# print("F", s.model()[F])


n = 1
results = []
while s.check() == sat and n <= 20 :
    m = s.model()
    results.append (m)
    s.add ( A != m[A] )
    n = n+1

# print models
for p in range (len (results)) :
    print("================================== model", p, "==================================")
    print(results[p])

